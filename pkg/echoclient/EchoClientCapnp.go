package echoclient

import (
	"context"
	"fmt"
	"log"
	"net"
	"time"

	"capnproto.org/go/capnp/v3/rpc"

	cb "github.com/hiveot/echorpc/capnp/go"
)

// EchoClientAdapter is a wrapper around Capnp RPC Echo service client
// ideally this would be generated by the compiler... hint hint ;)
type EchoClientAdapter struct {
	connection  *rpc.Conn
	ctx         context.Context
	ctxCancel   context.CancelFunc
	capnpClient cb.EchoService
}

func (echoClient *EchoClientAdapter) Echo(text string) (string, error) {
	var err error
	var echoText string

	resp, release := echoClient.capnpClient.Echo(echoClient.ctx,
		func(params cb.EchoService_echo_Params) error {
			err = params.SetText(text)
			return err
		})
	result, err := resp.Struct()
	if err == nil {
		echoText, err = result.EchoText()
	}
	release()
	return echoText, err
}

func (echoClient *EchoClientAdapter) Stats() (latest string, count int) {
	resp, release := echoClient.capnpClient.Stats(echoClient.ctx,
		func(params cb.EchoService_stats_Params) error {
			return nil
		})
	result, err := resp.Struct()
	if err != nil {
		return "", 0
	}
	st, err := result.Stats()
	latest, err = st.Latest()
	count = int(st.Count())
	release()
	return
}

func (echoClient *EchoClientAdapter) Close() {
	echoClient.ctxCancel()
}

func NewEchoClientAdapter(address string, isUDS bool) (*EchoClientAdapter, error) {
	network := "tcp"
	if isUDS {
		network = "unix"
	}
	connection, err := net.Dial(network, address)
	if err != nil {
		return nil, err
	}
	transport := rpc.NewStreamTransport(connection)
	rpcConn := rpc.NewConn(transport, nil)

	ctx, ctxCancel := context.WithTimeout(context.Background(), time.Second*200)

	// Q: in grpc this is NewEchoServiceClient. Why not do the same? - lower barrier to entry
	//    why the need to provide a bootstrap? Can the generated code create this?
	echoCapnpClient := cb.EchoService(rpcConn.Bootstrap(ctx))

	adapter := &EchoClientAdapter{
		connection:  rpcConn,
		ctx:         ctx,
		ctxCancel:   ctxCancel,
		capnpClient: echoCapnpClient,
	}

	return adapter, nil
}

// InvokeEchoCapnp Invoke the service using capnp rpc
func InvokeEchoCapnp(address string, isUDS bool, text string, count int) {

	echoClient, err := NewEchoClientAdapter(address, isUDS)
	if err != nil {
		log.Fatalf("failed creating echo client adapter: %s", err)
	}

	t1 := time.Now()
	for i := 0; i < count; i++ {
		echoText, err := echoClient.Echo(text)
		_ = echoText
		if err != nil {
			log.Fatalf("error getting echo text: %s", err)
		}

		// second call to get stats
		latest, count := echoClient.Stats()
		_ = latest
		_ = count
		// fmt.Println("Response:", echoText)
	}
	d1 := time.Since(t1)
	// round result
	msec := d1.Milliseconds() / 10 * 10
	fmt.Printf("%d calls using Capnp on %s: %d millisec\n", count, address, msec)

	echoClient.Close()

	// return response.Text, err
}
